(window.webpackJsonp=window.webpackJsonp||[]).push([[193],{656:function(e,r,t){"use strict";t.r(r);var o=t(18),n=Object(o.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("ul",[t("li",[t("a",{attrs:{href:"https://kubernetes.io/zh/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kubernetes"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://kubernetes.io/zh/docs/home/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kubernetes 文档"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://kubernetes.io/docs/reference/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Reference"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/",target:"_blank",rel:"noopener noreferrer"}},[e._v("One-page API Reference for Kubernetes v1.28"),t("OutboundLink")],1),e._v(" "),t("strong",[e._v("helpful link")])]),e._v(" "),t("li",[t("a",{attrs:{href:"https://kubernetes.io/docs/reference/using-api/deprecation-guide/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Deprecated API Migration Guide"),t("OutboundLink")],1),e._v(" "),t("strong",[e._v("helpful link")])]),e._v(" "),t("li",[t("a",{attrs:{href:"https://kubernetes.io/releases/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Release History"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Workload Resources"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://kubernetes.io/docs/reference/labels-annotations-taints/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Well-Known Labels, Annotations and Taints"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/kubernetes/examples",target:"_blank",rel:"noopener noreferrer"}},[e._v("Many of the examples provide an introduction to using kubectl"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://gitee.com/yooome/golang/blob/main/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kubernetes 详细教程"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.yuque.com/leifengyang/oncloud/ctiwgo",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kubernetes 核心实战"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://docs.sealos.io/zh-Hans/",target:"_blank",rel:"noopener noreferrer"}},[e._v("sealos"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"kubernetes-k8s-定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-k8s-定义"}},[e._v("#")]),e._v(" Kubernetes(k8s)定义")]),e._v(" "),t("ul",[t("li",[t("strong",[t("a",{attrs:{href:"https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kubernetes 是什么？"),t("OutboundLink")],1)])])]),e._v(" "),t("p",[e._v("Kubernetes(k8s) is an open source container orchestration engine for automating deployment, scaling, and management of containerized applications. The open source project is hosted by the Cloud Native Computing Foundation (CNCF).")]),e._v(" "),t("p",[t("code",[e._v("Open source platform")]),e._v(" for deployment and "),t("code",[e._v("management")]),e._v(" of arbitrary "),t("code",[e._v("container-based")]),e._v(" , "),t("code",[e._v("cloud native")]),e._v("applications on clusters of "),t("code",[e._v("servers")])]),e._v(" "),t("p",[e._v("Kubernetes 是用于自动部署，扩展和管理容器化应用程序的开源系统。"),t("br"),e._v("\n它将组成应用程序的容器组合成逻辑单元，以便于管理和服务发现。Kubernetes 源自 Google 15 年生产环境的运维经验，同时凝聚了社区的最佳创意和实践。")]),e._v(" "),t("p",[e._v("kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器----Borg 系统的一个开源版本，于 2014 年 9 月发布第一个版本，2015 年 7 月发布第一个正式版本。")]),e._v(" "),t("p",[e._v("kubernetes 的本质是"),t("strong",[e._v("一组服务器集群")]),e._v("，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("自我修复")]),e._v("：一旦某一个容器崩溃，能够在 1 秒中左右迅速启动新的容器")]),e._v(" "),t("li",[t("strong",[e._v("弹性伸缩")]),e._v("：可以根据需要，自动对集群中正在运行的容器数量进行调整")]),e._v(" "),t("li",[t("strong",[e._v("服务发现")]),e._v("：服务可以通过自动发现的形式找到它所依赖的服务")]),e._v(" "),t("li",[t("strong",[e._v("负载均衡")]),e._v("：如果一个服务起动了多个容器，能够自动实现请求的负载均衡")]),e._v(" "),t("li",[t("strong",[e._v("版本回退")]),e._v("：如果发现新发布的程序版本有问题，可以立即回退到原来的版本")]),e._v(" "),t("li",[t("strong",[e._v("存储编排")]),e._v("：可以根据容器自身的需求自动创建存储卷")])]),e._v(" "),t("h2",{attrs:{id:"kubernetes-组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-组件"}},[e._v("#")]),e._v(" Kubernetes 组件")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://kubernetes.io/zh/docs/concepts/overview/components/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kubernetes 组件"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("一个 kubernetes 集群主要是由"),t("strong",[e._v("主控节点(Master)/控制平面组件（Control Plane Components）")]),e._v("、"),t("strong",[e._v("工作节点(Node)")]),e._v(" 构成，每个节点上都会安装不同的组件。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg",alt:"Kubernetes cluster"}})]),e._v(" "),t("h3",{attrs:{id:"控制平面组件-control-plane-components"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#控制平面组件-control-plane-components"}},[e._v("#")]),e._v(" 控制平面组件（Control Plane Components）")]),e._v(" "),t("p",[e._v("集群的控制平面，负责集群的决策 (管理)")]),e._v(" "),t("p",[e._v("控制平面的组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 "),t("code",[e._v("replicas")]),e._v(" 字段时，启动新的 pod）。")]),e._v(" "),t("p",[e._v("控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器")]),e._v(" "),t("p",[t("strong",[e._v("1. kube-apiserver")])]),e._v(" "),t("ul",[t("li",[e._v("kube-apiserver 是 Kubernetes 控制面的组件")]),e._v(" "),t("li",[e._v("资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API 注册和发现等机制。")]),e._v(" "),t("li",[e._v("kube-apiserver 是 Kubernetes master 组件的前端。")]),e._v(" "),t("li",[e._v("可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。")]),e._v(" "),t("li",[e._v("提供 RESTful API 接口、集群的统一入口，集群的认证、授权、准入控制及各组件的协调者，所有的对象资源的增删改查和监听操作都交给 APIServer 处理后再提交给 etcd 数据库做持久化存储。")])]),e._v(" "),t("p",[t("strong",[e._v("2. kube-scheduler")])]),e._v(" "),t("ul",[t("li",[e._v("负责集群资源调度，按照预定的调度策略将 Pod 调度到相应的 node 节点上")]),e._v(" "),t("li",[e._v("控制平面组件，负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行。")]),e._v(" "),t("li",[e._v("调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。")]),e._v(" "),t("li",[e._v("在一个集群中，满足一个 Pod 调度请求的所有 Node 称之为 可调度 Node。调度器先在集群中找到一个 Pod 的可调度 Node， 然后根据一系列函数对这些可调度 Node 打分，之后选出其中得分最高的 Node 来运行 Pod。最后，调度器将这个调度决定告知 kube-apiserver，这个过程叫做 绑定（Binding)。")])]),e._v(" "),t("p",[t("strong",[e._v("3. kube-controller-manager")])]),e._v(" "),t("ul",[t("li",[e._v("负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等")]),e._v(" "),t("li",[e._v("负责管理集群各种资源，保证资源处于预期的状态。")]),e._v(" "),t("li",[e._v("从逻辑上讲，"),t("strong",[e._v("每个控制器都是一个单独的进程")]),e._v("， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。"),t("strong",[e._v("一个资源对应一个控制器")]),e._v("。 E.g: 有一个订单的任务， controller-manager 就会创一个 controller 对这个订单进行管理，又有一个购物车的任务，就会创建一个 controller 对这个购物车的任务进行管理。")])]),e._v(" "),t("p",[e._v("这些控制器包括:")]),e._v(" "),t("ul",[t("li",[e._v("节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应")]),e._v(" "),t("li",[e._v("任务控制器（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成")]),e._v(" "),t("li",[e._v("端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)")]),e._v(" "),t("li",[e._v("服务帐户和令牌控制器（Service Account & Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌")])]),e._v(" "),t("p",[t("strong",[e._v("4. etcd")])]),e._v(" "),t("ul",[t("li",[e._v("etcd 是一个高可用的分布式键值数据库，可用于服务发现。etcd 采用 raft 一致性算法，基于 Go 语言实现。etcd 作为一个高可用键值存储系统，天生就是为集群化而设计的。用于保存 Kubernetes 集群状态数据。")]),e._v(" "),t("li",[e._v("存储系统，负责存储集群中各种资源对象的信息。")])]),e._v(" "),t("p",[t("strong",[e._v("5. cloud-controller-manager")])]),e._v(" "),t("p",[e._v("云控制器管理器是指嵌入特定云的控制逻辑的 控制平面组件。 云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。\ncloud-controller-manager 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。")]),e._v(" "),t("p",[e._v("与 kube-controller-manager 类似，cloud-controller-manager 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。")]),e._v(" "),t("p",[e._v("下面的控制器都包含对云平台驱动的依赖：")]),e._v(" "),t("ul",[t("li",[e._v("节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除")]),e._v(" "),t("li",[e._v("路由控制器（Route Controller）: 用于在底层云基础架构中设置路由")]),e._v(" "),t("li",[e._v("服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器")])]),e._v(" "),t("h3",{attrs:{id:"node-组件-node-components"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-组件-node-components"}},[e._v("#")]),e._v(" Node 组件（Node Components）")]),e._v(" "),t("p",[e._v("集群的数据平面，负责为容器提供运行环境")]),e._v(" "),t("p",[e._v("节点组件在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行环境")]),e._v(" "),t("p",[t("strong",[e._v("1. kubelet")])]),e._v(" "),t("ul",[t("li",[e._v("负责维护容器的生命周期，比如通过控制 docker，来创建、更新、销毁容器")]),e._v(" "),t("li",[e._v("一个在集群中每个节点（node）上运行的代理。 它保证容器（containers）都运行在 Pod 中。")]),e._v(" "),t("li",[e._v("kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。")]),e._v(" "),t("li",[e._v("kubelet 是 master 派代 node 的代表（agent）")]),e._v(" "),t("li",[e._v("kubelet 是 mater 在 node 上的 agent，当 Scheduler 确定在某个 Node 上运行 Pod 后，会将 Pod 的具体配置信息（image、volume 等）发送给该节点的 kubelet，kubelet 会根据这些信息创建和运行容器，并向 master 报告运行状态。")])]),e._v(" "),t("p",[t("strong",[e._v("2. kube-proxy")])]),e._v(" "),t("ul",[t("li",[e._v("Kube-proxy 是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。")]),e._v(" "),t("li",[e._v("负责提供集群内部的服务发现和负载均衡")]),e._v(" "),t("li",[e._v("kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。")]),e._v(" "),t("li",[e._v("如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身")]),e._v(" "),t("li",[e._v("service 在逻辑上代表了后端的多个 Pod，外界通过 service 访问 Pod。service 接收到请求就需要 kube-proxy 完成转发到 Pod 的。 每个 Node 都会运行 kube-proxy 服务，负责将访问的 service 的 TCP/UDP 数据流转发到后端的容器，如果有多个副本，kube-proxy 会实现负载均衡，有 2 种方式：Iptables、或者 LVS")])]),e._v(" "),t("p",[t("strong",[e._v("3. 容器运行时（Container Runtime）")])]),e._v(" "),t("p",[e._v("容器运行环境是负责运行容器的软件。")]),e._v(" "),t("ul",[t("li",[e._v("容器运行环境是负责运行容器的软件。Kubernetes 支持多个容器运行环境: Docker（+ dockershim）、 containerd、CRI-O 以及任何其它实现 Kubernetes CRI (容器运行环境接口)。")])]),e._v(" "),t("p",[e._v("Kubernetes 支持多个容器运行环境: "),t("a",{attrs:{href:"https://kubernetes.io/zh/docs/reference/kubectl/docker-cli-to-kubectl/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker"),t("OutboundLink")],1),e._v("、 "),t("a",{attrs:{href:"https://containerd.io/docs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("containerd"),t("OutboundLink")],1),e._v("、"),t("a",{attrs:{href:"https://cri-o.io/#what-is-cri-o",target:"_blank",rel:"noopener noreferrer"}},[e._v("CRI-O"),t("OutboundLink")],1),e._v(" 以及任何实现 "),t("a",{attrs:{href:"https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Kubernetes CRI (容器运行环境接口)"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("h3",{attrs:{id:"各个组件调用关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#各个组件调用关系"}},[e._v("#")]),e._v(" 各个组件调用关系")]),e._v(" "),t("p",[e._v("下面，以部署一个 nginx 服务来说明 kubernetes 系统：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("首先要明确，一旦 kubernetes 环境启动之后，master 和 node 都会将自身的信息存储到 etcd 数据库中")])]),e._v(" "),t("li",[t("p",[e._v("一个 nginx 服务的安装请求会首先被发送到 master 节点的 apiServer 组件")])]),e._v(" "),t("li",[t("p",[e._v("apiServer 组件会调用 scheduler 组件来决定到底应该把这个服务安装到哪个 node 节点上")]),e._v(" "),t("p",[e._v("在此时，它会从 etcd 中读取各个 node 节点的信息，然后按照一定的算法进行选择，并将结果告知 apiServer")])]),e._v(" "),t("li",[t("p",[e._v("apiServer 调用 controller-manager 去调度 Node 节点安装 nginx 服务")])]),e._v(" "),t("li",[t("p",[e._v("kubelet 接收到指令后，会通知 docker，然后由 docker 来启动一个 nginx 的 pod")]),e._v(" "),t("p",[e._v("pod 是 kubernetes 的最小操作单元，容器必须跑在 pod 中")])]),e._v(" "),t("li",[t("p",[e._v("至此，一个 nginx 服务就运行了，如果需要访问 nginx，就需要通过 kube-proxy 来对 pod 产生访问的代理")])])]),e._v(" "),t("p",[e._v("这样，外界用户就可以访问集群中的 nginx 服务了")]),e._v(" "),t("h2",{attrs:{id:"kubernetes-工作原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-工作原理"}},[e._v("#")]),e._v(" kubernetes 工作原理")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://dlwang.xin:11796/image/cloud/k8s/k8s_working_principle.png",alt:"kubernetes 工作原理"}})]),e._v(" "),t("h2",{attrs:{id:"kubernetes-概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-概念"}},[e._v("#")]),e._v(" kubernetes 概念")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://www.cloudsavvyit.com/10107/pods-deployments-and-replica-sets-kubernetes-resources-explained/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Pods, Deployments and Replica Sets: Kubernetes Resources Explained"),t("OutboundLink")],1)])]),e._v(" "),t("h3",{attrs:{id:"controller"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#controller"}},[e._v("#")]),e._v(" Controller")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://kubernetes.io/zh/docs/concepts/architecture/controller/",target:"_blank",rel:"noopener noreferrer"}},[e._v("控制器"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("在机器人技术和自动化领域，控制回路（Control Loop）是一个非终止回路，用于调节系统状态。")]),e._v(" "),t("p",[e._v("这是一个控制环的例子：房间里的温度自动调节器。")]),e._v(" "),t("p",[e._v("当你设置了温度，告诉了温度自动调节器你的期望状态（Desired State）。 房间的实际温度是当前状态（Current State）。通过对设备的开关控制，温度自动调节器让其当前状态接近期望状态。")]),e._v(" "),t("p",[e._v("在 Kubernetes 中，控制器通过监控集群的公共状态，并致力于将当前状态转变为期望的状态。")]),e._v(" "),t("p",[e._v("通过它来实现对 pod 的管理，比如启动 pod、停止 pod、伸缩 pod 的数量等等")]),e._v(" "),t("h3",{attrs:{id:"pod"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pod"}},[e._v("#")]),e._v(" Pod")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://kubernetes.io/zh/docs/concepts/workloads/pods/#what-is-a-pod",target:"_blank",rel:"noopener noreferrer"}},[e._v("什么是 Pod？"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Pod 的生命周期"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("Pod 是可以在 Kubernetes 中创建和管理的、"),t("strong",[e._v("最小")]),e._v("的可部署的计算单元。"),t("br"),e._v("\n一个 pod 中可以有 1 个或者多个容器。Sidecar（边车）模式，以及服务网格 Istio 正是利用了 Pod 的这一特性")]),e._v(" "),t("p",[t("strong",[e._v("Pod （就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个）容器；这些容器共享存储、网络、以及怎样运行这些容器的声明")]),e._v("。 Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Pod 所建模的是特定于应用的“逻辑主机”，其中包含一个或多个应用容器， 这些容器是相对紧密的耦合在一起的。 在非云环境中，在相同的物理机或虚拟机上运行的应用类似于 在同一逻辑主机上运行的云应用。")]),e._v(" "),t("p",[e._v("除了应用容器，Pod 还可以包含在 Pod 启动期间运行的 "),t("a",{attrs:{href:"https://kubernetes.io/zh/docs/concepts/workloads/pods/init-containers/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Init 容器"),t("OutboundLink")],1),e._v("。 你也可以在集群中支持临时性容器 的情况下，为调试的目的注入临时性容器")]),e._v(" "),t("p",[e._v("和一个个独立的应用容器一样，Pod 也被认为是"),t("strong",[e._v("相对临时性（而不是长期存在）")]),e._v(" 的实体。 Pod 会被创建、赋予一个唯一的 ID（UID）， 并被调度到节点，并在终止（根据重启策略）或删除之前一直运行在该节点。")]),e._v(" "),t("h3",{attrs:{id:"replication-controller"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#replication-controller"}},[e._v("#")]),e._v(" Replication Controller")]),e._v(" "),t("p",[e._v('Kubernetes 提供 Replication Controller(简称"RC")来管理 Pod,Replication Controller 确保任何时候 Kubernetes 集群中有指定数量的 Pod 副 本在运行。如果少于指定数量的 Pod 副本，Replication Controller 会启动新的 Pod,反之会"Kill"多余的以保证数量不变。当 Pod 失败、被删除或被终 结时，RC 会自动创建新的 Pod 来保证副本的数量，所以即使只有一个 Pod，也应该使用 RC 来管理。除此之外，RC 还提供一些高级特性，比如滚动升级、回滚等。')]),e._v(" "),t("h3",{attrs:{id:"replicaset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#replicaset"}},[e._v("#")]),e._v(" ReplicaSet")]),e._v(" "),t("p",[e._v("升级版的 Replication Controller，用于确保与 Label Selector 匹配的 Pod 数量维持期望值。不同于 Replication Controller，Replica Set 引 入了基于子集的 Selector 查询条件 matchExpressions，而 Replication Controller 仅支持基于值完全匹配的 Selector 条件查询。社区引入 Replica Set 的初衷是：当 v1 版本被废弃时，Replication Controller 完成其历史使命，而由 ReplicaSet 来接管其工作。")]),e._v(" "),t("h3",{attrs:{id:"deployment"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#deployment"}},[e._v("#")]),e._v(" Deployment")]),e._v(" "),t("p",[e._v("Deployment 用来管理无状态应用的工作负载(应用程序集群)如：webserver 类集群。Deployment 为应用程序创建一或多个 RS,通过 RS 的模板和副本 保持的能力管理 pod,通过不同的 RS 管理应用程序的不同版本。")]),e._v(" "),t("p",[e._v("特性：")]),e._v(" "),t("ul",[t("li",[e._v("事件和状态查看：可以查看升级的详细进度和状态。")]),e._v(" "),t("li",[e._v("回滚：当升级 Pod 镜像或者相关参数的时候发现问题，可以使用回滚操作回滚到上一个稳定的版本或者指定的版本。")]),e._v(" "),t("li",[e._v("版本记录：每一次对 Deployment 的操作读能保存下来，给予后续可能的回滚使用。")]),e._v(" "),t("li",[e._v("暂停和启动: 对于每一次升级，都能够随时暂停和启动。")]),e._v(" "),t("li",[e._v("多种升级方案：\n"),t("ul",[t("li",[e._v("Recreate---删除所有已存在的 Pod，重新创建新的。")]),e._v(" "),t("li",[e._v("RollingUpdate---滚动升级，逐步替换的策略。滚动升级时支持更多的参数，如：设置最大不可用 Pod 数量、最小升级间隔时间等。")])])])]),e._v(" "),t("h3",{attrs:{id:"daemonset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#daemonset"}},[e._v("#")]),e._v(" DaemonSet")]),e._v(" "),t("p",[e._v("DaemonSet 控制器用于在集群中的全部（或者某些）节点上同时运行一个指定（有且只有一个）的 Pod 资源副本，后续新加入集群的工作节点也会自动创建一个相同 的 Pod 对象，当从集群移除节点时，此类 Pod 对象也将被自动回收而无需重建。删除 DaemonSet 将会删除它创建的所有 Pod。管理员也可以使用\nnodeSelector(节点选择器)及节点 label(标签)指定仅在部分具有特定特征的节点上运行指定的 Pod 对象。")]),e._v(" "),t("p",[e._v("应用场景：")]),e._v(" "),t("ul",[t("li",[e._v("在每个节点上运行集群存储 DaemonSet，例如 glusterd、ceph")]),e._v(" "),t("li",[e._v("在每个节点上运行日志收集 DaemonSet，例如 fluentd、logstash")]),e._v(" "),t("li",[e._v("在每个节点上运行监控 DaemonSet，例如 Prometheus Node Exporter、zabbix agent 等")])]),e._v(" "),t("h3",{attrs:{id:"job"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#job"}},[e._v("#")]),e._v(" Job")]),e._v(" "),t("p",[t("strong",[e._v("Job 控制器用于调配 pod 对象运行一次性任务")]),e._v("，容器中的进程在正常运行结束后不会对其进行重启，而是将 pod 对象置于“Completed”(完成)状态。 若容器中的进程因错误而终止，则需要依配置确定是否重启与否，未完成的 pod 对象因其所在的节点故障而意外终止后会被重新调度。")]),e._v(" "),t("p",[e._v("应用场景： 编译、离线数据处理、视频解码、HPC 等业务")]),e._v(" "),t("h3",{attrs:{id:"cronjob"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cronjob"}},[e._v("#")]),e._v(" Cronjob")]),e._v(" "),t("p",[e._v("CronJob 控制器用于管理 Job 控制器的运行时间。Job 控制器定义的作业任务在其控制器资源创建之后会立即运行，但 CronJob 可以类似于 Linux 操 作系统的周期性任务计划作业(crontab)的方式控制其运行的时间点及重复运行的方式。")]),e._v(" "),t("p",[e._v("应用场景： 通知，备份")]),e._v(" "),t("h3",{attrs:{id:"statefulset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#statefulset"}},[e._v("#")]),e._v(" StatefulSet")]),e._v(" "),t("p",[e._v("StatefulSet 是用来管理有状态应用的工作负载(应用程序集群)，管理 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。 和 Deployment 类似，StatefulSet 管理基于相同容器模板的一组 Pod。但和 Deployment 不同的是，StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的模板，但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。")]),e._v(" "),t("p",[e._v("应用场景：")]),e._v(" "),t("ul",[t("li",[e._v("集群成员需要有唯一的稳定的网络标识符")]),e._v(" "),t("li",[e._v("集群成员需要有稳定性，持久化数据存储")]),e._v(" "),t("li",[e._v("集群成员有序的部署、扩展、删除、终止、自动滚动更新")])]),e._v(" "),t("h3",{attrs:{id:"configmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#configmap"}},[e._v("#")]),e._v(" ConfigMap")]),e._v(" "),t("p",[e._v("ConfigMap 是一种存储非敏感数据的名称空间级别对象的资源：以键值对形式存储配置数据，将您的环境配置信息和容器镜像解耦，便于应用配置的 修改。使用时，Pods 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。")]),e._v(" "),t("h3",{attrs:{id:"secret"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#secret"}},[e._v("#")]),e._v(" Secret")]),e._v(" "),t("p",[e._v("Secret 是一种存储感数据的名称空间级别对象的资源：以键值对形式存储密码、token、dockercfg、证书")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://kubernetes.io/zh/docs/concepts/configuration/secret/#secret-types",target:"_blank",rel:"noopener noreferrer"}},[e._v("Secret 的类型"),t("OutboundLink")],1)])]),e._v(" "),t("h3",{attrs:{id:"service"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#service"}},[e._v("#")]),e._v(" Service")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。")])]),e._v(" "),t("li",[e._v("pod 对外服务的统一入口，下面可以维护着同一类的多个 pod")]),e._v(" "),t("li",[e._v("定义一组 pod 的访问规则")]),e._v(" "),t("li",[e._v("Pod 的负载均衡，提供一个或多个 Pod 的稳定访问地址")]),e._v(" "),t("li",[e._v("支持多种方式 ClusterIP、NodePort、LoadBalancer")])]),e._v(" "),t("h3",{attrs:{id:"label"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#label"}},[e._v("#")]),e._v(" Label")]),e._v(" "),t("ul",[t("li",[t("p",[t("a",{attrs:{href:"https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/labels/",target:"_blank",rel:"noopener noreferrer"}},[e._v("标签和选择算符"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("p",[e._v("用于对象资源查询，筛选")])]),e._v(" "),t("li",[t("p",[e._v("用于对 pod 进行分类，同一类 pod 会拥有相同的标签")])])]),e._v(" "),t("h3",{attrs:{id:"namespace"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#namespace"}},[e._v("#")]),e._v(" NameSpace")]),e._v(" "),t("ul",[t("li",[e._v("用来隔离 pod 的运行环境")]),e._v(" "),t("li",[e._v("一个集群内部的逻辑隔离机制【鉴权、资源】")]),e._v(" "),t("li",[e._v("每个资源都属于一个 namespace")]),e._v(" "),t("li",[e._v("同一个 namespace 所有资源不能重复，不同 namespace 可以资源名重复")])]),e._v(" "),t("h2",{attrs:{id:"kubernetes-部署工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-部署工具"}},[e._v("#")]),e._v(" Kubernetes 部署工具")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://minikube.sigs.k8s.io/docs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("minikube"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://kind.sigs.k8s.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("kind"),t("OutboundLink")],1)])]),e._v(" "),t("h3",{attrs:{id:"生产级别的部署工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生产级别的部署工具"}},[e._v("#")]),e._v(" 生产级别的部署工具")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://kubernetes.io/docs/reference/setup-tools/kubeadm/",target:"_blank",rel:"noopener noreferrer"}},[e._v("kubeadm"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://kops.sigs.k8s.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("kOps"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://kubespray.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("kubespray"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/k0sproject/k0s",target:"_blank",rel:"noopener noreferrer"}},[e._v("k0s"),t("OutboundLink")],1),e._v(" "),t("strong",[e._v("k0s - The Zero Friction Kubernetes")])])]),e._v(" "),t("h2",{attrs:{id:"others"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#others"}},[e._v("#")]),e._v(" Others")]),e._v(" "),t("h3",{attrs:{id:"容器运行时-container-runtime"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器运行时-container-runtime"}},[e._v("#")]),e._v(" 容器运行时（Container Runtime）")]),e._v(" "),t("p",[e._v("容器运行环境是负责运行容器的软件。")]),e._v(" "),t("h3",{attrs:{id:"集群-cluster"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集群-cluster"}},[e._v("#")]),e._v(" 集群（Cluster）")]),e._v(" "),t("p",[e._v("集群由一组被称为节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。")]),e._v(" "),t("h3",{attrs:{id:"容器-container"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容器-container"}},[e._v("#")]),e._v(" 容器（Container）")]),e._v(" "),t("p",[e._v("容器是可移植、可执行的轻量级镜像，镜像中包含软件及其相关依赖。")])])}),[],!1,null,null,null);r.default=n.exports}}]);