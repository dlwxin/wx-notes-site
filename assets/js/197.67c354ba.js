(window.webpackJsonp=window.webpackJsonp||[]).push([[197],{658:function(e,t,a){"use strict";a.r(t);var v=a(18),r=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"deployment-mainifests"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deployment-mainifests"}},[e._v("#")]),e._v(" Deployment mainifests")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("字段")]),e._v(" "),a("th",[e._v("类型")]),e._v(" "),a("th",[e._v("说明")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("minReadySeconds")]),e._v(" "),a("td",[a("code",[e._v("<integer>")])]),e._v(" "),a("td",[e._v("在新旧替换过程中，新建的 Pod 对象一旦成功响应就绪探测即被视为可用，而后即可立即开始下一轮的替换操作。 minReadySeconds 可指定新的 Pod 对象创建成功后要等待多久才会视其为就绪，在此期间，下一轮的操作会被阻塞。 默认为 0 秒。")])]),e._v(" "),a("tr",[a("td",[e._v("paused")]),e._v(" "),a("td",[a("code",[e._v("<boolean>")])]),e._v(" "),a("td",[e._v("布尔值，暂停后续的部署。在部署更新过程中，向 manifest 中添加该字段 paused: yes，使用 "),a("code",[e._v("kubectl apply -f deployment.yaml")]),e._v(" 暂停后续的部署更新。")])]),e._v(" "),a("tr",[a("td",[e._v("progressDeadlineSeconds")]),e._v(" "),a("td",[a("code",[e._v("<integer>")])]),e._v(" "),a("td",[e._v("部署在被认为失败之前进行的最长时间（秒）。部署控制器将持续处理失败的部署和标识为 ProgressDeadlineExceeded 状态的部署，直到达到该最大超时时间。paused 状态不计入此时长，默认 600 秒。")])]),e._v(" "),a("tr",[a("td",[e._v("replicas")]),e._v(" "),a("td",[a("code",[e._v("<integer>")])]),e._v(" "),a("td",[e._v("期望副本 pod 的总数量。默认为 1")])]),e._v(" "),a("tr",[a("td",[e._v("revisionHistoryLimit")]),e._v(" "),a("td",[a("code",[e._v("<integer>")])]),e._v(" "),a("td",[e._v("保留以允许回滚的旧 ReplicaSet 的数量。默认为 10")])]),e._v(" "),a("tr",[a("td",[e._v("selector")]),e._v(" "),a("td",[a("code",[e._v("<Object>")]),a("br"),e._v(" -required-")]),e._v(" "),a("td",[e._v("必填字段。pod 标签选择器。被其选择的 pod 的现有 ReplicaSet 将受到此部署的影响。它必须与 Pod template 的标 签匹配。")])]),e._v(" "),a("tr",[a("td",[e._v("strategy")]),e._v(" "),a("td",[a("code",[e._v("<Object>")])]),e._v(" "),a("td",[e._v("指定 deployment 的两种部署策略:RollingUpdate、Recreate，默认为 RollingUpdate")])]),e._v(" "),a("tr",[a("td",[e._v("template")]),e._v(" "),a("td",[a("code",[e._v("<Object>")]),a("br"),e._v(" -required-")]),e._v(" "),a("td",[e._v("描述创建 pod 资源的模板。")])])])]),e._v(" "),a("h2",{attrs:{id:"deployment-的两种更新策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deployment-的两种更新策略"}},[e._v("#")]),e._v(" Deployment 的两种更新策略")]),e._v(" "),a("h3",{attrs:{id:"recreat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#recreat"}},[e._v("#")]),e._v(" Recreat")]),e._v(" "),a("p",[e._v("首先删除现有的所有 pod 对象，而后又控制器基于新模板重新创建出新版本的资源对象。通常，只应该在应用的新旧本本不兼容（如依赖的后端数据 库的 schema 不同且无法兼容）时，\n运行才会使用 recreate 策略，因为他会导致应用替换期间暂时不可用，好处在于不存在中间状态，用户要么是应用新 的版本，要么是旧版本。")]),e._v(" "),a("h3",{attrs:{id:"rollingupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rollingupdate"}},[e._v("#")]),e._v(" RollingUpdate")]),e._v(" "),a("p",[e._v("默认更新策略，他在删除一部分旧版本 Pod 资源的同时，补充创建一部分新版本的 Pod 对象进行应用升级，其优势是升级期间，容器中应用提供的服务不会中断，但要求应用程序能够对新旧版本同时工作的情形，例如新旧版本兼容同一数据库方案。\n在更新操作期间，不同客户端得到的相应内容可能是来自同版本的应用。 Deployment 控制器的滚动更新操作并非在同一 ReplicaSet 控制器对象下删除并创建 Pod 资源，而是将他们分置于两个不同的控制器之下：旧的控制器的 Pod 对象数量不断减少的同时，新控制器的 Pod 对象数量不断增加，直到旧控制器不再拥有 Pod 对象，而新控制器的副本数量编的完全符合期望值为止。")]),e._v(" "),a("h2",{attrs:{id:"deployment-rollingupdate-的重要参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deployment-rollingupdate-的重要参数"}},[e._v("#")]),e._v(" Deployment rollingUpdate 的重要参数")]),e._v(" "),a("p",[e._v("pod 的生命周期的四个状态: Pending、ContainerCreating、Running、Terminating")]),e._v(" "),a("h3",{attrs:{id:"deployment-spec-strategy-rollingupdate-字段说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deployment-spec-strategy-rollingupdate-字段说明"}},[e._v("#")]),e._v(" "),a("code",[e._v("deployment.spec.strategy.rollingUpdate")]),e._v(" 字段说明")]),e._v(" "),a("p",[a("strong",[e._v("字段：maxSurge")])]),e._v(" "),a("p",[e._v("类型："),a("code",[e._v("<string>")])]),e._v(" "),a("p",[e._v("在更新期间，最多额外占用的 pod 数量")]),e._v(" "),a("ul",[a("li",[e._v("maxSurge 可以是一个数值，也可以是原有 pod 数量的百分比。默认为 25%。")]),e._v(" "),a("li",[e._v("总 pod 的数量（Pending+ContainerCreating+Running 状态的 pod）不超过期望的 "),a("strong",[e._v("replica")]),e._v(" 数量+maxSurge 或(100+maxSurge)%")])]),e._v(" "),a("p",[a("strong",[e._v("字段： maxUnavailable")])]),e._v(" "),a("p",[e._v("类型："),a("code",[e._v("<string>")])]),e._v(" "),a("p",[e._v("在更新期间，最多不可用的 pod 数量")]),e._v(" "),a("ul",[a("li",[e._v("maxUnavailable 可以是一个数值，也可以是原有 pod 数量的百分比。默认为 25%。")]),e._v(" "),a("li",[e._v("在更新期间，处于 running 状态的 pod 的最小数量为期望的 "),a("strong",[e._v("replica")]),e._v(" 数量-maxUnavailable 或(100-maxSurge)%")])]),e._v(" "),a("p",[e._v("Note: 以上两个字段不能同时为 0，同时为 0 即为 Recreate 策略")]),e._v(" "),a("h3",{attrs:{id:"版本更新说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#版本更新说明"}},[e._v("#")]),e._v(" 版本更新说明")]),e._v(" "),a("ul",[a("li",[e._v("滚动更新开始时，创建自动创建一个新的 RS。以批次为单位，在新版本 RS 中逐渐发布 pod，老版本 RS 中逐渐删除 pod 的过程，直到新版本 RS 中 pod 数量等于 Desired replicas,老版本 RS 中的 pod 等于 0，完成整个更新过程。")]),e._v(" "),a("li",[e._v("在更新过程占用整个集群系统资源的所有 pod 的总数（即：ContainerCreating+Running+Terminating 状态的 pods）= Desired replicas+maxSurge")]),e._v(" "),a("li",[e._v("在更新过程中，最少可用的 pod 数量为 Desired replicas - maxUnavailable")]),e._v(" "),a("li",[e._v("假设版本更新过程中新老版本的 RS 分别为 rs-0、rs-1，开始阶段 rs-0 中保留 Desired replicas - maxUnavailable 个 pod，rs-1 发布 maxSurge+maxUnavailable 个 pod")])]),e._v(" "),a("p",[a("strong",[e._v("值得注意的一点是，在考虑 Deployment 应在更新期间运行的 Pod 数量时，使用的是在 Deployment 的更新版本中指定的副本数，而不是现有 Deployment 版本的期望状态中指定的副本数。")])]),e._v(" "),a("h3",{attrs:{id:"触发部署或部署更新的-3-种方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#触发部署或部署更新的-3-种方式"}},[e._v("#")]),e._v(" 触发部署或部署更新的 3 种方式")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("kubectl edit deployment")])]),e._v(" "),a("li",[a("code",[e._v("kubectl apply -f | kubectl replace -f | kubectl patch")])]),e._v(" "),a("li",[a("code",[e._v("kubectl set | kubectl scale")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);