(window.webpackJsonp=window.webpackJsonp||[]).push([[199],{662:function(v,t,_){"use strict";_.r(t);var e=_(18),r=Object(e.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"kubernetes-存储类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-存储类型"}},[v._v("#")]),v._v(" kubernetes 存储类型")]),v._v(" "),_("p",[v._v("pod.spec.volumes|template.spec.volumes")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://dlwang.xin:11796/image/cloud/k8s/k8s_storage_type.png",alt:"kubernetes 存储类型"}})]),v._v(" "),_("p",[_("strong",[v._v("Container 的两种消费模型")])]),v._v(" "),_("p",[v._v("所有的存储资源，最终都是给 Pod 中的 Container 使用。Container 是存储真正的消费者。")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("pod.spec.containers.volumeMounts")]),v._v(" 把存储卷资源挂载到 Container 上 mountPath 路径（文件系统存储）")]),v._v(" "),_("li",[_("code",[v._v("pod.spec.containers.volumeDevices")]),v._v(" 把存储卷映射成 Container 内的 devicePath 上的设备（块存储）")])]),v._v(" "),_("p",[v._v("默认使用的存储都是容器运行时提供的临时存储。")]),v._v(" "),_("h3",{attrs:{id:"emptydir-存储类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#emptydir-存储类型"}},[v._v("#")]),v._v(" emptyDir 存储类型")]),v._v(" "),_("p",[v._v("使用节点上 kubelet 的临时存储("),_("code",[v._v("/var/lib/kubelet/pods")]),v._v(")或节点上的内存，为同一个 pod 中的不同容器（主容器与主容器之间、与初始化容器之间），在启动或运行阶段共享传递数据，临时存储终止 pod 后数据擦除。")]),v._v(" "),_("p",[_("code",[v._v("pod.spec.volumes.emptyDir.spec")]),v._v(" 卷类型字段说明")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("字段")]),v._v(" "),_("th",[v._v("类型")]),v._v(" "),_("th",[v._v("说明")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("medium")]),v._v(" "),_("td",[_("code",[v._v("<string>")])]),v._v(" "),_("td",[v._v('指定后端存储介质类型，默认为空，使用 worker 节点 kubelet 临时存储，"Memory"代表 pod 所在 worker 节点的物理内存。')])]),v._v(" "),_("tr",[_("td",[v._v("sizeLimit")]),v._v(" "),_("td",[_("code",[v._v("<string>")])]),v._v(" "),_("td",[v._v("可使用临时存储最大容量限制。默认为空，不做限制。")])])])]),v._v(" "),_("p",[_("strong",[v._v("Examples")])]),v._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://gitee.com/dlwxin/example-kubernetes/blob/main/manifests/storage/volumes/storage-volumes-emptydir-nginx-01.yaml",target:"_blank",rel:"noopener noreferrer"}},[v._v("storage-volumes-emptydir-nginx-01.yaml"),_("OutboundLink")],1)]),v._v(" "),_("li",[_("a",{attrs:{href:"https://gitee.com/dlwxin/example-kubernetes/blob/main/manifests/storage/volumes/storage-volumes-emptydir-nginx-02.yaml",target:"_blank",rel:"noopener noreferrer"}},[v._v("storage-volumes-emptydir-nginx-02.yaml"),_("OutboundLink")],1)]),v._v(" "),_("li",[_("a",{attrs:{href:"https://gitee.com/dlwxin/example-kubernetes/blob/main/manifests/storage/volumes/storage-volumes-emptydir-sidecar-01.yaml",target:"_blank",rel:"noopener noreferrer"}},[v._v("storage-volumes-emptydir-sidecar-01.yaml"),_("OutboundLink")],1)])]),v._v(" "),_("h3",{attrs:{id:"hostpath-存储类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hostpath-存储类型"}},[v._v("#")]),v._v(" hostPath 存储类型")]),v._v(" "),_("p",[v._v("使用 Pod 所在节点的本机文件系统为同一个 worker 节点上的不同 pod 之间共享数据，提供持久存储。")]),v._v(" "),_("p",[v._v("hostPath 存储类型字段说明")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("字段")]),v._v(" "),_("th",[v._v("类型")]),v._v(" "),_("th",[v._v("说明")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("path")]),v._v(" "),_("td",[_("code",[v._v("<string>")]),_("br"),v._v("-required-")]),v._v(" "),_("td",[v._v("pod 所在的 node 节点的文件系统实体路径。")])]),v._v(" "),_("tr",[_("td",[v._v("type")]),v._v(" "),_("td",[_("code",[v._v("<string>")])]),v._v(" "),_("td",[v._v("HostPath 卷的类型，默认为空无需指定。支持的类型：DirectoryOrCreate、Directory、FileOrCreate、File、Socket、CharDevice、 BlockDevice")])])])]),v._v(" "),_("h3",{attrs:{id:"nfs-第三方存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nfs-第三方存储"}},[v._v("#")]),v._v(" NFS 第三方存储")]),v._v(" "),_("p",[v._v("第三方存储 nfs 字段说明")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("字段")]),v._v(" "),_("th",[v._v("类型")]),v._v(" "),_("th",[v._v("说明")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("server")]),v._v(" "),_("td",[_("code",[v._v("<string>")]),_("br"),v._v("-required-")]),v._v(" "),_("td",[v._v("nfs 服务器 ip 地址或可解析的主机名")])]),v._v(" "),_("tr",[_("td",[v._v("path")]),v._v(" "),_("td",[_("code",[v._v("<string>")]),_("br"),v._v("-required-")]),v._v(" "),_("td",[v._v("nfs 服务器输出路径")])]),v._v(" "),_("tr",[_("td",[v._v("readOnly")]),v._v(" "),_("td",[_("code",[v._v("<boolean>")])]),v._v(" "),_("td",[v._v("设置是否为只读，布尔值，默认为 false")])])])]),v._v(" "),_("h2",{attrs:{id:"kubernetes-pv-pvc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-pv-pvc"}},[v._v("#")]),v._v(" Kubernetes pv pvc")]),v._v(" "),_("h3",{attrs:{id:"pv-spec-字段说明"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#pv-spec-字段说明"}},[v._v("#")]),v._v(" "),_("code",[v._v("pv.spec")]),v._v(" 字段说明")]),v._v(" "),_("p",[_("strong",[v._v("accessModes 字段")])]),v._v(" "),_("p",[v._v("类型："),_("code",[v._v("<[]string>")])]),v._v(" "),_("p",[v._v("定义存储的访问模式：支持以下三种模式：")]),v._v(" "),_("ul",[_("li",[v._v("ReadWriteOnce: 仅可被单个 node 节点以读写方式挂载。简写为 RWO")]),v._v(" "),_("li",[v._v("ReadOnlyMany: 可以被多个 node 节点以只读的方式挂载。简写为 ROX")]),v._v(" "),_("li",[v._v("ReadWriteMany: 可以被多个 node 节点以读写的方式挂载。简写为 RWX")])]),v._v(" "),_("p",[v._v("注意：即使一种卷支持多种模式，也只能一次使用一种访问模式挂载该卷。例如，GCEPersistentDisk 可以由单个节点使 用 ReadWriteOnce 挂载，也可以由许多节点使用 ReadOnlyMany 模式挂载，但不能同时以两种模式挂载。")]),v._v(" "),_("p",[_("strong",[v._v("capacity 字段")])]),v._v(" "),_("p",[v._v("类型："),_("code",[v._v("<map[string] string>")])]),v._v(" "),_("p",[v._v("定义 pv 的性能指标。目前仅可用的指标为容量指标：storage: N，将来的属性会增加 IOPS，throughput 等。")]),v._v(" "),_("div",{staticClass:"language-yaml line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-yaml"}},[_("code",[v._v("capacity：\n  "),_("span",{pre:!0,attrs:{class:"token key atrule"}},[v._v("Storage")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" 2Gi\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br")])]),_("p",[_("strong",[v._v("persistentVolumeReclaimPolicy 字段")])]),v._v(" "),_("p",[v._v("类型："),_("code",[v._v("<string>")])]),v._v(" "),_("p",[v._v("定义 PV 存储的回收策略。")]),v._v(" "),_("p",[v._v("● Retain(保留策略):")]),v._v(" "),_("p",[v._v('默认策略，删除 PVC 之后，Kubenetes 不会自动删除 PV，而仅将它置于"释放"(released)状态，此种状态的 PV 不能 被其他 PVC 申请绑定，此前产生的数据仍然保留。如需再次使用，需要管理员手动清除，步骤：')]),v._v(" "),_("ol",[_("li",[v._v("删除 PV，这之后，此 PV 的数据仍然留存于外部的存储之上。")]),v._v(" "),_("li",[v._v("手动清理存储系统上依然留存的数据。")]),v._v(" "),_("li",[v._v("再次将其重新创建为 PV。")])]),v._v(" "),_("p",[v._v("● Delete(删除策略)：")]),v._v(" "),_("p",[v._v("对于支持 Delete 回收策略的插件来说，在 PVC 被删除后会直接移除 PV 对象，同时擦除存储上的数据。支持这种操作 的存储系统有 AWS EBS、GCE PD、Azure Disk、OpenStack Cinder")]),v._v(" "),_("p",[v._v("● Recycle(回收策略)：")]),v._v(" "),_("p",[v._v("如果可以被底层插件支持，资源回收策略会在存储卷上执行数据删除操作并让 PV 资源再次变为可被其它 PVC 申请。另 外，管理员也可以配置一个自定义的回收器 Pod 模板，以便执行自定义的回收操作。只有 NFS 和 HostPath 类型的存储支持 recycling 策略。"),_("strong",[v._v("此种回收策略将被废弃")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("storageClassName 字段")])]),v._v(" "),_("p",[v._v("类型："),_("code",[v._v("<string>")])]),v._v(" "),_("p",[v._v("PV 可以具有一个类，该类名字可以通过将 storageClassName 设置。")]),v._v(" "),_("ul",[_("li",[v._v("特定类别的 PV 只能绑定到请求该类别的 PVC。")]),v._v(" "),_("li",[v._v("没有 storageClassName 的 PV 没有类别，只能绑定到不要求特定类别的 PVC。")])]),v._v(" "),_("p",[_("strong",[v._v("mountOptions 字段")])]),v._v(" "),_("p",[v._v("类型："),_("code",[v._v("<[]string>")])]),v._v(" "),_("p",[v._v('管理员为挂载存储指定挂载参数列表。如 ["ro", "soft"]')]),v._v(" "),_("p",[_("strong",[v._v("volumeMode 字段")])]),v._v(" "),_("p",[v._v("类型："),_("code",[v._v("<string>")])]),v._v(" "),_("p",[v._v("如果外部存储为块设备，支持两种模式:Filesystem 和 Block。volumeMode 是可选的 API 参数。默认模式为 Filesystem。")]),v._v(" "),_("ul",[_("li",[v._v("Filesystem：如果该卷底层使用的是块设备，且该设备为空，则 Kuberneretes 会在首次安装该设备之前在该设备上 创建一个文件系统。")]),v._v(" "),_("li",[v._v("Block：将卷用作原始块设备。这样的卷作为一个块设备呈现在 Pod 中，上面没有任何文件系统。此模式对于为 Pod 提供最快的访问卷的方式很有用，而 Pod 和卷之间没有任何文件系统层")])]),v._v(" "),_("h3",{attrs:{id:"不同存储类型所支持的访问方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不同存储类型所支持的访问方式"}},[v._v("#")]),v._v(" 不同存储类型所支持的访问方式")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("Volume Plugin")]),v._v(" "),_("th",[v._v("ReadWriteOnce")]),v._v(" "),_("th",[v._v("ReadOnlyMany")]),v._v(" "),_("th",[v._v("ReadWriteMany")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("AWSElasticBlockStore")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")]),v._v(" "),_("td",[v._v("-")])]),v._v(" "),_("tr",[_("td",[v._v("AzureDisk")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")]),v._v(" "),_("td",[v._v("-")])]),v._v(" "),_("tr",[_("td",[v._v("GCEPersistentDisk")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")])]),v._v(" "),_("tr",[_("td",[v._v("Cinder")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")]),v._v(" "),_("td",[v._v("-")])]),v._v(" "),_("tr",[_("td",[v._v("VsphereVolume")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")]),v._v(" "),_("td",[v._v("- (works when Pods are collocated)")])]),v._v(" "),_("tr",[_("td",[v._v("HostPath")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")]),v._v(" "),_("td",[v._v("-")])]),v._v(" "),_("tr",[_("td",[v._v("StorageOS")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")]),v._v(" "),_("td",[v._v("-")])]),v._v(" "),_("tr",[_("td",[v._v("iSCSI")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")])]),v._v(" "),_("tr",[_("td",[v._v("FC")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")])]),v._v(" "),_("tr",[_("td",[v._v("RBD")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")])]),v._v(" "),_("tr",[_("td",[v._v("FlexVolume")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")])]),v._v(" "),_("tr",[_("td",[v._v("ScaleIO")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")])]),v._v(" "),_("tr",[_("td",[v._v("Flocker")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")])]),v._v(" "),_("tr",[_("td",[v._v("NFS")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")])]),v._v(" "),_("tr",[_("td",[v._v("Glusterfs")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")])]),v._v(" "),_("tr",[_("td",[v._v("CephFS")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")])]),v._v(" "),_("tr",[_("td",[v._v("AzureFile")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")])]),v._v(" "),_("tr",[_("td",[v._v("Quobyte")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("✓")])]),v._v(" "),_("tr",[_("td",[v._v("PortworxVolume")]),v._v(" "),_("td",[v._v("✓")]),v._v(" "),_("td",[v._v("-")]),v._v(" "),_("td",[v._v("✓")])]),v._v(" "),_("tr",[_("td",[v._v("CSI")]),v._v(" "),_("td",[v._v("depends on the driver")]),v._v(" "),_("td",[v._v("depends on the driver")]),v._v(" "),_("td",[v._v("depends on the driver")])])])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("类别")]),v._v(" "),_("th",[v._v("Volume Plugin")]),v._v(" "),_("th",[v._v("访问方式")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("DAS")]),v._v(" "),_("td",[v._v("AWSElasticBlockStore,GCEPersistentDisk,AzureDisk")]),v._v(" "),_("td",[v._v("ReadwriteOnce")])]),v._v(" "),_("tr",[_("td",[v._v("SAN")]),v._v(" "),_("td",[v._v("iSCSI,FC,RBD")]),v._v(" "),_("td",[v._v("ReadOnlyMany")])]),v._v(" "),_("tr",[_("td",[v._v("NAS")]),v._v(" "),_("td",[v._v("NFS,CephFS,Glusterfs,AzureFile")]),v._v(" "),_("td",[v._v("ReadWriteMany")])])])])])}),[],!1,null,null,null);t.default=r.exports}}]);